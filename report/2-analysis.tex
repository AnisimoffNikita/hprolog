\chapter{Основная часть}

\section{Характеристика предприятия}
Московский государственный технический университет им. Н. Э. Баумана -- российский национальный исследовательский университет, научный центр, особо ценный объект культурного наследия народов России.

Информация о кафедре ИУ-7.
\begin{itemize}
		\item Заведующий кафедрой: к.т.н., доцент Рудаков Игорь Владимирович
		\item Год создания: 1989
		\item Назначение кафедры:
		Готовит специалистов широкого профиля в области проектирования и разработки программного обеспечения. С 2011 года выпускает бакалавров и магистров по направлениям подготовки 09.03.04 и 09.04.04 "Программная инженерия"
\end{itemize}


Основные направления обучения
\begin{itemize}
	\item Программная инженерия: Принципы и методы проектирования и разработки информационных систем.
	\item Системное программирование:  Низкоуровневое программирование, разработка драйверов устройств, программирование в режиме ядра ОС, вопросы проектирования ОС.
	\item Конструирование компиляторов: Теория формальных языков и практика создания компиляторов.
	\item Программирование баз данных: Математические основы баз данных, проектирование и разработка ПО, использующего базы данных.

	\item Сетевое программирование:
	Изучение сетевых протоколов, создание собственных реализаций сетевых стандартов, создание новых протоколов.
	
	\item Машинная и инженерная графика:
	Реализация алгортимов компьютерной графики, создание фотореалистичных изображений.
	
	\item Компьютерное моделирование:
	Моделирование непрерывных и дискретных систем, численные методы.
	
	\item Интеллектуальные системы:
	Математические основы и реализация экспертных систем, систем принятия решений, систем обработки естественного языка.
	
	\item Библиотечные информационные системы:
	Проектирование и разработка информационно-поисковых систем, классификация информации.
\end{itemize}



















\section{Основные элементы языка Пролог}
Основным элементом языка является терм.
Терм -- это либо константа, либо переменная, либо составной терм. 
Составной терм показывает наличие отношения между аргументами. 
Константа -- это символьный атом, начинающийся с маленькой буквы. 
Именованная переменная -- это символьный атом, начинающийся с большой буквы. 
Символьный атом является неименованной переменной, если он начинается с символа \_. 
Составной терм -- это терм вида \(f(t1,t2..tn)\), где \(t1,t2..tn\) -- термы-аргументы, \(f\) -- главный функтор или имя. отношения. Количество \(n\) аргументов -- арность. 

\section{Особенности использования переменных}
Переменная конкретизирована, если в некий момент времени ей соответствует значение. Именованная переменная уникальная в рамках одного предложения. Анонимная переменная всегда уникальна. Она не может быть конкретизирована и не может передать значение на другой шаг доказательства.

\section{Структура программы}
Программа состоит из базы знаний и вопроса. База знаний -- из фактов и правил.
Правило -- это <<условная истина>> или <<теорема>>. Имеет следующий вид: \textit{<заголовок>:-<тело>}.
Факт -- <<безусловная истина>>, <<аксиома>>, правило без тела. Факт -- частный случай
правила.
Факт без переменных называется основной.
Вопрос -- это специальный тип предложений. Ответом на вопрос является либо да, либо нет. Побочный эффект -- данные, при которых был получен ответ да. 
Факты, правила и вопрос представляются в виде терма.

\section{Понятие процедуры}
Процедура -- совокупность правил, заголовки которых согласуются с одной и той же целью (одно сложно определенное знание). Процедуры нужны, когда знание не умещается в одно предложение.

\section{Подстановка}
Подстановкой называется множество пар вида \(\{x_i = t_i\}\), где \(t_i\) это термы не содержащие переменных. Пусть \(\Theta=\{x_1 = t_1, x_2 = t_2 ... x_n = t_n\}\). Если \(A\) -- терм, то результатом подстановки является \(A\Theta\). Применение подстановки заключается в замене всех вхождений переменной \(x_i\) на соответствующий терм \(t_i\). 

Терм \(B\) является примером терма \(A\), если существует подстановка \(\Theta\), такая что \(B=A\Theta\). Терм \(C\) называется общим примером термов \(A\) и \(B\), если существует такие подстановки \(\Theta_1\) и \(\Theta_2 \), что \(C=A\Theta_1 \) и \(C=B\Theta_2 \).

\section{Алгоритм унификации}
Алгоритм унификации основной шаг доказательства. С помощью данного алгоритма происходит:
\begin{itemize}
	\item [1.] двунаправленная передача параметров процедурам,
	\item [2.] неразрушающее присваивание,
	\item [3.] проверка условий.
\end{itemize}

При унификации двух термов \(\Theta_1 \) и \(\Theta_2 \)  возможны следующие случаи:
\begin{list}{\textbullet }{}
	\item если \(\Theta_1 \) и \(\Theta_2 \) константы, и они совпадают, то унификация успешна;
	\item если \(\Theta_1 \)  не конкретизированная переменная, а \(\Theta_2 \) -- константа, или составной терм, не содержащий в качестве аргумента \(\Theta_1 \) , то унификация успешна, а \(\Theta_1 \)  конкретизируется значением \(\Theta_2 \);
	\item если \(\Theta_1 \)  и \(\Theta_2 \) не конкретизированные переменные, то их унификация всегда успешна, причем  и  становятся сцепленными, а при конкретизации одной из переменных, другая конкретизируется автоматически тем же значением.
	\item если \(\Theta_1 \)  и \(\Theta_2 \) составные термы, то они успешно унифицируются если выполнены следующие условия:
	\begin{list}{$\circ$ }{}
		\item \(\Theta_1 \)  и \(\Theta_2 \) имеют одинаковые главные функторы;
		\item \(\Theta_1 \)  и \(\Theta_2 \) имеют равные арности;
		\item каждая пара соответствующих аргументов успешно унифицируется. 
	\end{list}
\end{list}

\section{Наиболее общий унификатор}
Терм \(S\) является более общим, чем терм \(T\), если \(T\) является примером  \(S\), а \(S\) не является примером \(T\).
Терм \(S\) наиболее общий пример термов \(T_1\) и \(T_2\), если \(S\) такой их общий пример, который является более общим по отношению к любому другому их примеру. Унификатор двух термов -- подстановка, которая будучи применена к каждому терму даст одинаковый результат. Наиболее общим унификатором двух термов называется унификатор, соответствующий наиболее общему примеру термов. 
 
\section{Порядок работы}
Работы начинается с задания вопроса. Сверху вниз система просматривает базу знаний и пытается унифицировать вопрос с заголовком правила. Возможна неудача и успех. В случае неудачи, система пытается унифицировать вопрос с заголовком следующего правила. Если  унификация прошла успешна, то результатом является флаг и наибольший общий унификатор.

\section{Резольвента}
На каждом шаге доказательства имеется конъюнкция целей, называемая резольвентой. Если резольвента пуста, то достигнут однократный успех. Преобразование резольвенты происходит с помощью редукции.

Редукцией цели \(G\) с помощью программы \(P\) называется замена цели \(G\) телом того правила из \(P\), заголовок которого унифицируется с целью \(G\). Такие правила, заголовки которых унифицируются с целью, называются сопоставимыми с целью.
 
Новая резольвента получается в два этапа:
\begin{itemize}
	\item [1.] в текущей резольвенте выбирается одна из целей, и для нее выполняется редукция;
	\item [2.] в полученной конъюнкции целей применяется подстановка, полученная как наибольший общий унификатор цели и заголовка, сопоставленного с ней правила.
\end{itemize}

\section{Список}
Список в языке Пролог организуется при помощи составного терма c главным функтором \texttt{'.'} и арностью равной двум, и с помощью специального терма \texttt{[]}, представляющим собой пустой список. Список целых чисел от 1 до 3 выглядит следующим образом \texttt{'.'(1, '.'(2, '.'(3, [])))}. Для упрощение был введен дополнительный синтаксис. Выражение \texttt{[1,2,3]} представляет собой <<синтаксический сахар>> для представления списка.