\chapter{Технологический раздел}

В качестве языка программирования был выбран язык Haskell.  

\section{Синтаксический анализатор}
Для разработки синтаксического анализатора требовалось описать все возможные структуры языка Пролог.

\lstinputlisting[caption = {Описание программы}, label={lst1:syntax},language=Haskell, firstline=6, lastline=37]{../src/Language/Prolog/Syntax.hs}

Чтобы разобрать текст программы, необходимо описать, как разобрать любую его структуру. Например, при помощи пакета \texttt{parsec}, чтобы проверить, является ли строка числом, необходимо написать следующий код, представленный в листинге \ref{lst2:syntax}.

\lstinputlisting[caption = {Парсер целого числа}, label={lst2:syntax},language=Haskell, firstline=214, lastline=225]{../src/Language/Prolog/Parser.hs}

В листинге \ref{lst3:syntax} представлен код, необходимый, чтобы получить число, как описанную ранее структуру данных.

\lstinputlisting[caption = {Парсер структуры языка}, label={lst3:syntax},language=Haskell, firstline=16, lastline=32]{../src/Language/Prolog/Parser.hs}

Подобные действия необходимо выполнить для каждой структуры данных.

\section{Алгоритм унификации}
Алгоритм унификации на языке Haskell представлен в листинге \ref{lst4:unifi}.
\lstinputlisting[caption = {Алгоритм унификации}, label={lst4:unifi},language=Haskell, firstline=286, lastline=301]{../src/Language/Prolog/Algorithm.hs}

На вход функции подается два терма. В качестве возвращаемого значения, в случае успешной унификации будет возвращена новая цель (если унифицировались составные термы), и возможная подстановка (подстановка возможная, т.к. в случае унификации двух констант или составных термов, подстановка выработана не будет).

\section{Резольвента}
Резольвента описывается при помощи типа данных, приведенной в листинге \ref{lst4:resolv}.
\lstinputlisting[caption = {Резольвента}, label={lst4:resolv},language=Haskell, firstline=39, lastline=41]{../src/Language/Prolog/Algorithm.hs}

Она представляет собой список, каждый элемент которого хранит два значения: заголовок и тело правила. Необходимость хранения заголовка обусловлено работой алгоритма отсечения. Заголовка может не быть, в случае если это первоначальный вопрос.

\section{Доказательство}
В листинге \ref{lst4:proof} показан шаг обработки текущей цели.
\lstinputlisting[caption = {Доказательство}, label={lst4:proof},language=Haskell, firstline=111, lastline=144]{../src/Language/Prolog/Algorithm.hs}

В первую очередь проверяется резольвента. Если она пуста, то возвращается выработанная подстановка. Если все цели из текущего правила закончились, то переход к целям из тела следующего правила.
Если встречено отсечение, то продолжается поиск решений в данной ветке, но вместе с найденными результатами возвращается метка отсечения.
Далее происходит сравнение текущего терма с другими стандартными термами. Если все сравнения прошли неудачно, то вызывается стандартный обработчик, представленный в листинге \ref{lst4:default}.
\lstinputlisting[caption = {Доказательство}, label={lst4:default},language=Haskell, firstline=199, lastline=223]{../src/Language/Prolog/Algorithm.hs}

В данном обработчике выполняется попытка унификации текущей цели со всеми возможными правилами. В случае успешной унификации происходит преобразование резольвенты для каждой отдельной ветки. Если в какой-то момент встречается метка отсечения, и она соответствует текущему терму, то следующие ветки в списке отбрасываются.

\section{Последовательный поиск решение}
Последовательный поиск решений реализуется автоматически, благодаря ленивой природе вычислений в языке Haskell. Если необходимо только первое решение, то будет найдено только оно, и вычисления прекратятся. Если потребуется следующее решение, то вычисления продолжатся.

\section{Пример работы программы}
Для программы нахождения факториала, приведенной в листинге , построено дерево, изображенное на рисунке .

Для программы нахождения совершенных чисел, приведенной в листинге , дерево построено быть не может, т.к. программа может выполняться бесконечно, но решения могут быть найдены последовательно.